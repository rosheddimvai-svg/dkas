import telegram
from telegram import Update, KeyboardButton, ReplyKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, JobQueue
from datetime import datetime, timedelta
import pytz
import random
import os
import logging

# рж▓ржЧрж┐ржВ рж╕рзЗржЯржЖржк
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)

# --- ржЖржкржирж╛рж░ ржжрзЗржУрзЯрж╛ рждржерзНржп ---
BOT_TOKEN = "7845699149:AAEEKpzHFt5gd6LbApfXSsE8de64f8IaGx0"
ADMIN_ID = "@Soyabur_AS_leaders" # ржПржЦрж╛ржирзЗ ржЖржкржирж╛рж░ ржЕрзНржпрж╛ржбржорж┐ржи ржЖржЗржбрж┐ ржжрж┐ржи
CHANNEL_NAME = "ЁЭСиЁЭС║ ЁЭС╢ЁЭСнЁЭСнЁЭС░ЁЭСкЁЭС░ЁЭСиЁЭС│ ЁЭСкЁЭСпЁЭСиЁЭС╡ЁЭС╡ЁЭСмЁЭС│" # ржПржЦрж╛ржирзЗ ржЖржкржирж╛рж░ ржЪрзНржпрж╛ржирзЗрж▓рзЗрж░ ржирж╛ржо ржжрж┐ржи
CHANNEL_ID = -1002787846366 # ржЖржкржирж╛рж░ ржжрзЗржУрзЯрж╛ ржЪрзНржпрж╛ржирзЗрж▓ ржЖржЗржбрж┐
# --- рждржерзНржп рж╢рзЗрж╖ ---

# ржмрж╛ржВрж▓рж╛ржжрзЗрж╢ ржЯрж╛ржЗржоржЬрзЛржи рж╕рзЗржЯ ржХрж░рж╛
BANGLADESH_TIMEZONE = pytz.timezone('Asia/Dhaka')

# ржкрзНрж░рждрж┐ржЯрж┐ ржорж┐ржирж┐ржЯрзЗрж░ ржЬржирзНржп ржПржХржЯрж┐ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ рж╕рж┐ржЧржирзНржпрж╛рж▓ рждрзИрж░рж┐ ржПржмржВ рж╕ржВрж░ржХрзНрж╖ржг ржХрж░рж╛рж░ ржЬржирзНржп ржЧрзНрж▓рзЛржмрж╛рж▓ ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓
minute_signals = {}
last_updated_minute = -1

# рж╕рж┐ржЧржирзНржпрж╛рж▓ рждрзИрж░рж┐ ржХрж░ржмрзЗ
def generate_signal_for_minute(minute):
    random.seed(minute)
    return random.choice(["Big", "Small"])

# рж╕рзНржмржпрж╝ржВржХрзНрж░рж┐ржпрж╝ржнрж╛ржмрзЗ ржЪрзНржпрж╛ржирзЗрж▓рзЗ рж╕рж┐ржЧржирзНржпрж╛рж▓ ржкрж╛ржарж╛ржмрзЗ
async def send_scheduled_signal(context: ContextTypes.DEFAULT_TYPE) -> None:
    global minute_signals, last_updated_minute
    
    current_datetime_bst = datetime.now(BANGLADESH_TIMEZONE)
    current_minute = current_datetime_bst.minute
    
    # ржирждрзБржи рзл ржорж┐ржирж┐ржЯрзЗрж░ рж╕рзНрж▓ржЯрзЗ ржкрзНрж░ржмрзЗрж╢ ржХрж░рж▓рзЗ рж╕рж┐ржЧржирзНржпрж╛рж▓ ржЖржкржбрзЗржЯ ржХрж░рж╛
    if current_minute % 5 != last_updated_minute:
        minute_signals = {}
        last_updated_minute = current_minute % 5
        # ржкрж░ржмрж░рзНрждрзА рзл ржорж┐ржирж┐ржЯрзЗрж░ ржЬржирзНржп рж╕рж┐ржЧржирзНржпрж╛рж▓ ржЬрзЗржирж╛рж░рзЗржЯ ржХрж░рж╛
        for i in range(5):
            future_minute = (current_minute + i) % 60
            minute_signals[i] = generate_signal_for_minute(future_minute)
    
    formatted_start_time = current_datetime_bst.strftime('%H:%M:%S')
    end_datetime = current_datetime_bst + timedelta(minutes=4, seconds=(59 - current_datetime_bst.second))
    formatted_end_time = end_datetime.strftime('%H:%M:%S')

    signal_list = ""
    for i, signal in minute_signals.items():
        future_time = current_datetime_bst + timedelta(minutes=i)
        future_formatted_time = future_time.strftime('%H:%M')
        signal_list += f"ЁЯОп **{future_formatted_time}** тЮбя╕П `{signal}`\n"
    
    signal_message = (
        f"**тХнтФАтФА тЛЕ тЛЕ тФАтФА тЬй тФАтФА тЛЕ тЛЕ тФАтФАтХо**\n"
        f"        **{CHANNEL_NAME}**\n"
        f"**тХ░тФАтФА тЛЕ тЛЕ тФАтФА тЬй тФАтФА тЛЕ тЛЕ тФАтФАтХп**\n"
        f"\n"
        f"ЁЯФо **ржлрж┐ржЙржЪрж╛рж░ рж╕рж┐ржЧржирзНржпрж╛рж▓ ржЬрзЗржирж╛рж░рзЗржЯрж░**\n"
        f"**рж╢рзБрж░рзБ:** `{formatted_start_time}`\n"
        f"**рж╢рзЗрж╖:** `{formatted_end_time}`\n"
        f"\n"
        f"**ржкрж░ржмрж░рзНрждрзА рж╕рж┐ржЧржирзНржпрж╛рж▓ржЧрзБрж▓рзЛ:**\n"
        f"{signal_list}\n"
        f"**тФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФА**\n"
        f"тЬи **рж╕ржлрж▓рждрж╛ ржирж┐рж╢рзНржЪрж┐ржд ржХрж░рждрзЗ ржЖржорж╛ржжрзЗрж░ рж╕рж╛ржерзЗ ржерж╛ржХрзБржи!** тЬи\n"
        f"**тФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФА**"
    )
    
    try:
        await context.bot.send_message(chat_id=CHANNEL_ID, text=signal_message, parse_mode='Markdown')
        logging.info("Scheduled signal sent successfully.")
    except telegram.error.TelegramError as e:
        logging.error(f"Failed to send message to channel: {e}")

# /start ржХржорж╛ржирзНржб рж╣рзНржпрж╛ржирзНржбрзЗрж▓рж╛рж░: ржПржЯрж┐ ржУржпрж╝рзЗрж▓ржХрж╛ржо ржорзЗрж╕рзЗржЬ ржПржмржВ ржорзЗржирзБ ржмрж╛ржЯржи ржжрзЗржЦрж╛ржмрзЗ
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    welcome_message = (
        f"**тХнтФАтФА тЛЕ тЛЕ тФАтФА тЬй тФАтФА тЛЕ тЛЕ тФАтФАтХо**\n"
        f"        **{CHANNEL_NAME}**\n"
        f"**тХ░тФАтФА тЛЕ тЛЕ тФАтФА тЬй тФАтФА тЛЕ тЛЕ тФАтФАтХп**\n"
        f"\n"
        f"ЁЯСЛ **рж╕рзНржмрж╛ржЧрждржо!**\n"
        f"тЬи ржПржЗ ржмржЯржЯрж┐ ржПржХ ржорж╛рж╕рзЗрж░ ржЬржирзНржп ржмрж┐ржирж╛ржорзВрж▓рзНржпрзЗ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рждрзЗ ржкрж╛рж░ржмрзЗржиред\n"
        f"ЁЯЪА ржПржЦрж╛ржирзЗ ржЖржкржирж┐ WinGo 1M ржЧрзЗржорзЗрж░ ржЬржирзНржп рж╕рж┐ржЧржирзНржпрж╛рж▓ ржкрж╛ржмрзЗржиред\n"
        f"ЁЯФФ ржирзЛржЯрж┐ржлрж┐ржХрзЗрж╢ржи ржЪрж╛рж▓рзБ рж░рж╛ржЦрзБржи ржПржмржВ ржкрзНрж░рждрж┐ржжрж┐ржирзЗрж░ рж╕рж┐ржЧржирзНржпрж╛рж▓ ржкрзЗрждрзЗ ржерж╛ржХрзБржиред"
    )
    
    keyboard = [
        [KeyboardButton("ЁЯТ░ Get Signal")],
        [KeyboardButton("ЁЯСитАНЁЯТ╗ Contact Admin"), KeyboardButton("ЁЯУЬ Rules")],
        [KeyboardButton("тЬНя╕П Registration")]
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    
    await update.message.reply_text(welcome_message, parse_mode='Markdown')
    await update.message.reply_text('ржирж┐ржЪрзЗрж░ ржорзЗржирзБ ржерзЗржХрзЗ ржЖржкржирж╛рж░ ржкрзНрж░ржпрж╝рзЛржЬржирзАржпрж╝ ржмрж╛ржЯржиржЯрж┐ ржирж┐рж░рзНржмрж╛ржЪржи ржХрж░рзБржи:', reply_markup=reply_markup)

# ржорзЗрж╕рзЗржЬ рж╣рзНржпрж╛ржирзНржбрзЗрж▓рж╛рж░: ржЯрзЗржХрзНрж╕ржЯ ржмрж╛рж░рзНрждрж╛рж░ ржЬржирзНржп
async def message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    text = update.message.text
    
    if text == "ЁЯТ░ Get Signal":
        await get_signal_message(update, context)
    elif text == "ЁЯСитАНЁЯТ╗ Contact Admin":
        await contact_admin(update, context)
    elif text == "ЁЯУЬ Rules":
        await rules(update, context)
    elif text == "тЬНя╕П Registration":
        await registration(update, context)

# рж╕рж┐ржЧржирзНржпрж╛рж▓ ржкрж╛ржУрзЯрж╛рж░ ржЬржирзНржп рж╣рзНржпрж╛ржирзНржбрзЗрж▓рж╛рж░ (ржорзНржпрж╛ржирзБржпрж╝рж╛рж▓ ржмрзНржпржмрж╣рж╛рж░ржХрж╛рж░рзАржжрзЗрж░ ржЬржирзНржп)
async def get_signal_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    global minute_signals, last_updated_minute
    
    current_datetime_bst = datetime.now(BANGLADESH_TIMEZONE)
    current_minute = current_datetime_bst.minute
    
    # ржирждрзБржи ржорж┐ржирж┐ржЯрзЗ ржкрзНрж░ржмрзЗрж╢ ржХрж░рж▓рзЗ рж╕рж┐ржЧржирзНржпрж╛рж▓ ржЖржкржбрзЗржЯ ржХрж░рж╛
    if current_minute % 5 != last_updated_minute:
        minute_signals = {}
        last_updated_minute = current_minute % 5
        # ржкрж░ржмрж░рзНрждрзА рзл ржорж┐ржирж┐ржЯрзЗрж░ ржЬржирзНржп рж╕рж┐ржЧржирзНржпрж╛рж▓ ржЬрзЗржирж╛рж░рзЗржЯ ржХрж░рж╛
        for i in range(5):
            future_minute = (current_minute + i) % 60
            minute_signals[i] = generate_signal_for_minute(future_minute)
    
    formatted_start_time = current_datetime_bst.strftime('%H:%M:%S')
    end_datetime = current_datetime_bst + timedelta(minutes=4, seconds=(59 - current_datetime_bst.second))
    formatted_end_time = end_datetime.strftime('%H:%M:%S')

    signal_list = ""
    for i, signal in minute_signals.items():
        future_time = current_datetime_bst + timedelta(minutes=i)
        future_formatted_time = future_time.strftime('%H:%M')
        signal_list += f"ЁЯОп **{future_formatted_time}** тЮбя╕П `{signal}`\n"
    
    signal_message = (
        f"**тХнтФАтФА тЛЕ тЛЕ тФАтФА тЬй тФАтФА тЛЕ тЛЕ тФАтФАтХо**\n"
        f"        **{CHANNEL_NAME}**\n"
        f"**тХ░тФАтФА тЛЕ тЛЕ тФАтФА тЬй тФАтФА тЛЕ тЛЕ тФАтФАтХп**\n"
        f"\n"
        f"ЁЯФо **ржлрж┐ржЙржЪрж╛рж░ рж╕рж┐ржЧржирзНржпрж╛рж▓ ржЬрзЗржирж╛рж░рзЗржЯрж░**\n"
        f"**рж╢рзБрж░рзБ:** `{formatted_start_time}`\n"
        f"**рж╢рзЗрж╖:** `{formatted_end_time}`\n"
        f"\n"
        f"**ржкрж░ржмрж░рзНрждрзА рж╕рж┐ржЧржирзНржпрж╛рж▓ржЧрзБрж▓рзЛ:**\n"
        f"{signal_list}\n"
        f"**тФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФА**\n"
        f"тЬи **рж╕ржлрж▓рждрж╛ ржирж┐рж╢рзНржЪрж┐ржд ржХрж░рждрзЗ ржЖржорж╛ржжрзЗрж░ рж╕рж╛ржерзЗ ржерж╛ржХрзБржи!** тЬи\n"
        f"**тФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФА**"
    )
    
    await update.message.reply_text(signal_message, parse_mode='Markdown')

# ржХржирзНржЯрж╛ржХрзНржЯ ржПржбржорж┐ржи рж╣рзНржпрж╛ржирзНржбрзЗрж▓рж╛рж░
async def contact_admin(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text(f"ЁЯСитАНЁЯТ╗ ржЕрзНржпрж╛ржбржорж┐ржи ржПрж░ рж╕рж╛ржерзЗ ржпрзЛржЧрж╛ржпрзЛржЧ ржХрж░рждрзЗ ржПржЦрж╛ржирзЗ ржХрзНрж▓рж┐ржХ ржХрж░рзБржи: {ADMIN_ID}")

# рж░рзБрж▓рж╕ ржжрзЗржЦрж╛ржирзЛрж░ ржЬржирзНржп рж╣рзНржпрж╛ржирзНржбрзЗрж▓рж╛рж░
async def rules(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    rules_text = (
        "**ЁЯУЬ ржирж┐рзЯржорж╛ржмрж▓рзА:**\n"
        "1. ржПржЗ рж╕рж┐ржЧржирзНржпрж╛рж▓ржЧрзБрж▓рзЛ рж╢рзБржзрзБржорж╛рждрзНрж░ WinGo 1M ржЦрзЗрж▓рж╛рж░ ржЬржирзНржпред\n"
        "2. рж╕рж┐ржЧржирзНржпрж╛рж▓ржЧрзБрж▓рзЛ ржЕрждрзАржд ржлрж▓рж╛ржлрж▓рзЗрж░ ржЙржкрж░ ржнрж┐рждрзНрждрж┐ ржХрж░рзЗ рждрзИрж░рж┐ ржХрж░рж╛ рж╣ржпрж╝ ржПржмржВ рж╕ржмрж╕ржоржпрж╝ рж╕ржарж┐ржХ ржирж╛ржУ рж╣рждрзЗ ржкрж╛рж░рзЗред\n"
        "3. ржЦрзЗрж▓рж╛ржЯрж┐ ржирж┐ржЬ ржжрж╛рзЯрж┐рждрзНржмрзЗ ржЦрзЗрж▓ржмрзЗржиред\n"
    )
    await update.message.reply_text(rules_text, parse_mode='Markdown')

# рж░рзЗржЬрж┐рж╕рзНржЯрзНрж░рзЗрж╢ржи рж╣рзНржпрж╛ржирзНржбрзЗрж▓рж╛рж░
async def registration(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text("тЬНя╕П рж░рзЗржЬрж┐рж╕рзНржЯрзНрж░рзЗрж╢ржи ржХрж░рждрзЗ ржПржЦрж╛ржирзЗ ржХрзНрж▓рж┐ржХ ржХрж░рзБржи: https://dkwin12.com/#/register?invitationCode=82626111964")

def main() -> None:
    try:
        application = Application.builder().token(BOT_TOKEN).build()
        
        # ржХржорж╛ржирзНржб ржПржмржВ ржорзЗрж╕рзЗржЬ рж╣рзНржпрж╛ржирзНржбрзЗрж▓рж╛рж░
        application.add_handler(CommandHandler("start", start))
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, message_handler))

        # рж╕рзНржмржпрж╝ржВржХрзНрж░рж┐ржпрж╝ рж╕рж┐ржЧржирзНржпрж╛рж▓ ржкрж╛ржарж╛ржирзЛрж░ ржЬржирзНржп JobQueue
        job_queue = application.job_queue
        if job_queue:
            job_queue.run_repeating(send_scheduled_signal, interval=5*60, first=0) # ржкрзНрж░рждрж┐ рзл ржорж┐ржирж┐ржЯрзЗ рж╕рж┐ржЧржирзНржпрж╛рж▓ ржкрж╛ржарж╛ржмрзЗ
        else:
            logging.warning("JobQueue is not available or initialized incorrectly.")
        
        application.run_polling(allowed_updates=Update.ALL_TYPES)
        
    except Exception as e:
        logging.error(f"An error occurred in the main function: {e}")

if __name__ == '__main__':
    main()
